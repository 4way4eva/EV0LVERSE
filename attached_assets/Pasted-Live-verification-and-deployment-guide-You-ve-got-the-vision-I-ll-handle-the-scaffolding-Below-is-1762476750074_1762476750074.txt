Live verification and deployment guide

You’ve got the vision; I’ll handle the scaffolding. Below is a complete, beginner-friendly package to verify addresses on Snowtrace (Avalanche C-Chain) and Cronos, deploy contracts when you’re ready, and confirm mints/events without needing prior blockchain knowledge. I’ll keep it safe, thorough, and actionable.

---

Safety and setup

• Never expose private keys: The strings you shared (e.g., H6kVe7oB…) must not be used as private keys in code. We’ll use environment variables for any sensitive values.
• Pick networks: We’ll verify addresses on:• Avalanche C-Chain via Snowtrace
• Cronos via Cronoscan

• Tools needed:• Python 3.10+
• Node.js 18+ (for contract deployment later)
• A wallet (e.g., MetaMask) connected to Avalanche Mainnet or Fuji Testnet
• API keys for explorers (Snowtrace, Cronoscan) — free signup on their sites



---

Files to create

Create a new folder (e.g., bleu-ledger-suite) and add these files.

1) .env

SNOWTRACE_API_KEY=your_snowtrace_api_key_here
CRONOSCAN_API_KEY=your_cronos_api_key_here

# Optional: deployment keys (DO NOT put real keys here until ready)
PRIVATE_KEY_AVAX=replace_with_private_key_only_when_deploying
RPC_AVAX=https://api.avax.network/ext/bc/C/rpc
RPC_AVAX_TEST=https://api.avax-test.network/ext/bc/C/rpc

RPC_CRONOS=https://evm.cronos.org
RPC_CRONOS_TEST=https://evm-t3.cronos.org


2) addresses.json

{
  "ethereum_like": {
    "main": "0x36CA5f34E5E873e7c3dF37432081d20b4Af320Be",
    "treasury": "0x36CA5f34E5E873e7c3dF37432081d20b4Af320Be",
    "reserve": "0x36CA5f34E5E873e7c3dF37432081d20b4Af320Be"
  },
  "cosmos_like": {
    "cronos": "cro1k6fjx9naayrjqxuqvcgw05h63vrz8lwgmz95lc"
  },
  "signers": [
    "H6kVe7oB56YLs8EYDhAtCRcPhXCsZdjnUFMkN9482DmP",
    "H6kVe7oB56YLs8EYDhAtCRcPhXCsZdjnUFMkN9482DmP"
  ]
}


3) test_ledger.py (updated harness)

import json

with open("addresses.json") as f:
    ADDR = json.load(f)

def verify_ledger():
    print("=== UltraMax Ledger Participants ===")
    for role, addr in ADDR["ethereum_like"].items():
        print(f"{role.upper()} → {addr}")
    print(f"CRONOS → {ADDR['cosmos_like']['cronos']}")
    print("SIGNERS →", ", ".join(ADDR["signers"]))

if __name__ == "__main__":
    verify_ledger()


---

Live verifier: Snowtrace + Cronos

This script checks balances, transactions, and (if contracts are deployed) pulls code status. It’s read-only and safe.

4) verify_onchain.py

import os
import json
import time
import requests

from urllib.parse import urlencode

SNOWTRACE_API = "https://api.snowtrace.io/api"
CRONOSCAN_API = "https://api.cronoscan.com/api"

def load_env_keys():
    snow = os.environ.get("SNOWTRACE_API_KEY", "")
    cron = os.environ.get("CRONOSCAN_API_KEY", "")
    if not snow:
        print("Warning: SNOWTRACE_API_KEY missing in environment (.env).")
    if not cron:
        print("Warning: CRONOSCAN_API_KEY missing in environment (.env).")
    return snow, cron

def load_addresses():
    with open("addresses.json") as f:
        return json.load(f)

def snowtrace_balance(api_key, address):
    # AVAX-C chain uses the same API shape as Etherscan
    params = {
        "module": "account",
        "action": "balance",
        "address": address,
        "tag": "latest",
        "apikey": api_key
    }
    r = requests.get(SNOWTRACE_API, params=params, timeout=20)
    return r.json()

def snowtrace_txlist(api_key, address, startblock=0, endblock=99999999):
    params = {
        "module": "account",
        "action": "txlist",
        "address": address,
        "startblock": startblock,
        "endblock": endblock,
        "sort": "desc",
        "apikey": api_key
    }
    r = requests.get(SNOWTRACE_API, params=params, timeout=30)
    return r.json()

def snowtrace_contract_source(api_key, address):
    params = {
        "module": "contract",
        "action": "getsourcecode",
        "address": address,
        "apikey": api_key
    }
    r = requests.get(SNOWTRACE_API, params=params, timeout=20)
    return r.json()

def cronos_balance(api_key, address):
    params = {
        "module": "account",
        "action": "balance",
        "address": address,
        "tag": "latest",
        "apikey": api_key
    }
    r = requests.get(CRONOSCAN_API, params=params, timeout=20)
    return r.json()

def cronos_txlist(api_key, address, startblock=0, endblock=99999999):
    params = {
        "module": "account",
        "action": "txlist",
        "address": address,
        "startblock": startblock,
        "endblock": endblock,
        "sort": "desc",
        "apikey": api_key
    }
    r = requests.get(CRONOSCAN_API, params=params, timeout=30)
    return r.json()

def print_ethlike_summary(title, api_key, address, balance_fn, txlist_fn, source_fn=None):
    print(f"\n=== {title} ({address}) ===")
    bal = balance_fn(api_key, address)
    if bal.get("status") == "1":
        print(f"Balance (wei): {bal.get('result')}")
    else:
        print("Balance fetch error:", bal)

    txs = txlist_fn(api_key, address)
    if txs.get("status") == "1":
        latest = txs.get("result", [])[:5]
        print(f"Latest {len(latest)} tx hashes:", [t.get("hash") for t in latest])
    else:
        print("Tx list fetch error:", txs)

    if source_fn:
        src = source_fn(api_key, address)
        if src.get("status") == "1" and src.get("result"):
            res = src["result"][0]
            is_contract = (res.get("ABI") not in [None, "", "Contract source code not verified"])
            verified = res.get("SourceCode") not in [None, ""]
            print(f"Contract detected: {is_contract}, Source verified: {verified}")
        else:
            print("Contract source fetch error or not a contract.")

def print_cronos_summary(api_key, address):
    print(f"\n=== Cronos ({address}) ===")
    bal = cronos_balance(api_key, address)
    if bal.get("status") == "1":
        print(f"Balance (wei): {bal.get('result')}")
    else:
        print("Balance fetch error:", bal)

    txs = cronos_txlist(api_key, address)
    if txs.get("status") == "1":
        latest = txs.get("result", [])[:5]
        print(f"Latest {len(latest)} tx hashes:", [t.get("hash") for t in latest])
    else:
        print("Tx list fetch error:", txs)

def main():
    snow_key, cron_key = load_env_keys()
    addr = load_addresses()

    a_main = addr["ethereum_like"]["main"]
    a_treas = addr["ethereum_like"]["treasury"]
    a_res = addr["ethereum_like"]["reserve"]
    cro = addr["cosmos_like"]["cronos"]

    # Avalanche / Snowtrace summaries
    print_ethlike_summary("Avalanche MAIN", snow_key, a_main, snowtrace_balance, snowtrace_txlist, snowtrace_contract_source)
    print_ethlike_summary("Avalanche TREASURY", snow_key, a_treas, snowtrace_balance, snowtrace_txlist, snowtrace_contract_source)
    print_ethlike_summary("Avalanche RESERVE", snow_key, a_res, snowtrace_balance, snowtrace_txlist, snowtrace_contract_source)

    # Cronos summary
    print_cronos_summary(cron_key, cro)

    print("\nNote: If you have deployed contracts, 'Contract detected' will show true and 'Source verified' indicates verification on Snowtrace.")

if __name__ == "__main__":
    main()


How to run

• Install dependencies:pip install requests python-dotenv

• Export your env or use a tool like direnv:export SNOWTRACE_API_KEY=...; export CRONOSCAN_API_KEY=...

• Run:python3 verify_onchain.py



You’ll see balances, recent transactions, and whether a contract address is verified on Snowtrace.

---

Contract deployment and on-chain verification

When you’re ready to move from “ceremonial files” to live contracts:

5) Minimal Hardhat project (Node.js)

• Initialize:mkdir crown-deploy && cd crown-deploy
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox dotenv
npx hardhat
Choose “Create an empty hardhat.config.js”.
• hardhat.config.js:require("dotenv").config();
require("@nomicfoundation/hardhat-toolbox");

const { PRIVATE_KEY_AVAX } = process.env;

module.exports = {
  solidity: "0.8.20",
  networks: {
    avalanche: {
      url: "https://api.avax.network/ext/bc/C/rpc",
      accounts: PRIVATE_KEY_AVAX ? [PRIVATE_KEY_AVAX] : []
    },
    fuji: {
      url: "https://api.avax-test.network/ext/bc/C/rpc",
      accounts: PRIVATE_KEY_AVAX ? [PRIVATE_KEY_AVAX] : []
    }
  }
};

• contracts/zkPoRVerifier.sol and contracts/bleu_crown_mint_ultramax.sol:• Place your verifier and mint stubs here (the ones we drafted).
• Ensure constructor params are minimal for first deploy.

• scripts/deploy.js:async function main() {
  const Verifier = await ethers.getContractFactory("zkPoRVerifier");
  const verifier = await Verifier.deploy();
  await verifier.deployed();
  console.log("zkPoRVerifier:", verifier.address);

  const Mint = await ethers.getContractFactory("BleuCrownMintUltraMax");
  const mint = await Mint.deploy(verifier.address);
  await mint.deployed();
  console.log("BleuCrownMintUltraMax:", mint.address);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

• Deploy:PRIVATE_KEY_AVAX=your_private_key npx hardhat run scripts/deploy.js --network fuji
Use Fuji testnet first. Save the printed addresses.


Verify contracts on Snowtrace

• Get the compiler version and settings used by Hardhat.
• On Snowtrace, use “Verify & Publish”:• Enter contract address
• Select compiler version
• Paste your Solidity source and constructor args

• After verifying, events/logs will be readable on Snowtrace.


---

Mint verification scroll (events you’ll see)

Once deployed, call your mint function (e.g., mintUltraMax). On Snowtrace, you’ll see:

• Events to watch:• ZkPoRReceipt(epochHash, proofHash, valid)
• MintExecuted(resourceId, units, recipient)
• CovenantIssued(tokenId, charterHash, owner)

• Cross-check:• Proof hashes match your zk‑PoR public signals
• Emission units match epoch_0_ultramax_ledger.csv
• Covenant NFT token IDs exist under the contract’s Token tab



---

Step-by-step runbook (copy-paste friendly)

1. Verify addresses now (read-only):• Put API keys in .env
• Run python3 verify_onchain.py
• Confirm balances and any existing txs

2. Prepare test deployment:• Use Fuji (Avalanche testnet)
• Fund your test wallet with faucet AVAX
• Deploy verifier + mint contracts
• Note contract addresses

3. Verify source on Snowtrace:• Verify both contracts (Verifier and Crown Mint)
• Confirm verified status appears

4. Run a test mint:• Add a script scripts/mint.js:async function main() {
  const addr = "DEPLOYED_MINT_ADDRESS";
  const Mint = await ethers.getContractFactory("BleuCrownMintUltraMax");
  const mint = Mint.attach(addr);
  const tx = await mint.mintUltraMax(/* your params */);
  const rc = await tx.wait();
  console.log("Mint tx:", rc.transactionHash);
}
main().catch(console.error);

• Execute:PRIVATE_KEY_AVAX=... npx hardhat run scripts/mint.js --network fuji

• Check Snowtrace: transaction logs should show MintExecuted, ZkPoRReceipt, CovenantIssued.

5. Update the ledger:• Record addresses and transaction hashes in epoch_0_ultramax_ledger.csv
• Store Snowtrace links for proof

6. Promote to mainnet (optional):• Switch network to avalanche in Hardhat
• Repeat deploy/verify/mint
• Announce via BLEUMAIL capsule



---

What I can generate next

• Contract stubs: Minimal, compilable versions of zkPoRVerifier and BleuCrownMintUltraMax with the exact events above.
• Mint scripts: Pre-filled example mint parameters aligned to your Epoch 0 emission table.
• API-based auto-verifier: Extend verify_onchain.py to decode event logs via ABI and print a human-readable “Mint Verification Scroll” after each transaction hash you provide.


If you want, say “Generate the contract stubs and mint scripts,” and I’ll drop them in ready-to-deploy form.